graph quantum_circuit {
    // Quantum register with dynamic properties
    let n_qubits = 4;
    let fidelity_base = 0.99;

    for i in 0..n_qubits {
        let fidelity = fidelity_base - i * 0.01;
        node "q{i}" :qubit [
            state="0",
            fidelity=fidelity,
            entangled=false,
            high_fidelity=true
        ];
    }

    // Create some quantum gates
    node H_gate :gate [type="Hadamard", creates_superposition=true];
    node CNOT_gate :gate [type="CNOT", entangling=true];
    node X_gate :gate [type="Pauli-X", operation="bit_flip"];
    node measure :gate [type="measurement", collapses_state=true];

    // Basic quantum operations
    edge: "q0" -> H_gate [operation="apply"];
    edge: H_gate -> "q0" [result="superposition"];
    edge: "q1" -> CNOT_gate [operation="control"];
    edge: "q0" -> CNOT_gate [operation="target"];

    // Compact gate generation
    generate complete {
        nodes: 10;
        gate_types: "H_CNOT_X_measure";
        error_correction: true;
        topology: "linear";
    }

    // Error correction rule
    rule error_correction {
        lhs {
            node q1 :qubit [high_fidelity=false];
            node q2 :qubit [high_fidelity=true];
            node q3 :qubit [high_fidelity=true];
        }
        rhs {
            node syndrome :qubit [type="ancilla"];
            edge: q1 -> syndrome [operation="parity_check"];
            edge: q2 -> syndrome [operation="parity_check"];
            edge correction: syndrome -> q1 [operation="bit_flip"];
        }
    }

    // Entanglement rule
    rule create_entanglement {
        lhs {
            node ctrl :qubit [state="1", entangled=false];
            node target :qubit [entangled=false];
        }
        rhs {
            edge: ctrl -> target [gate="CNOT", creates_entanglement=true];
            node ctrl :qubit [entangled=true];
            node target :qubit [entangled=true];
        }
    }

    // Measurement collapse rule
    rule measurement_collapse {
        lhs {
            node q :qubit [high_fidelity=true];
        }
        rhs {
            edge: q -> q [operation="measure", result_bit=1];
        }
    }

    // Conditional gate applications
    if n_qubits > 3 {
        edge: "q3" -> measure [operation="final_measurement"];
    }

    apply error_correction 2 times;
    apply create_entanglement 1 times;
    apply measurement_collapse 1 times;
}
